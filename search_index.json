[
["index.html", "Community contributions for EDAV Fall 2019 Chapter 1 Instructions 1.1 Background 1.2 Preparing your .Rmd file 1.3 Submission Steps 1.4 Optional tweaks 1.5 FAQ", " Community contributions for EDAV Fall 2019 2019-10-27 Chapter 1 Instructions This chapter gives you all the information you need to upload your community contribution. 1.1 Background This web site makes use of the bookdown package to render a collection of .Rmd files into a nicely formatted online book with chapters and subchapters. Your job will be to submit a slightly modified version of your community contribution .Rmd file to the GitHub repository where the source files for this web site are stored. On the backend, the admins will divide the chapters into book sections and order them. We use Travis CI to render the book and push the rendered .html files to our gh-pages branch–you can view our builds here–and GitHub Pages to host the site. If your community contribution is in a different format, then create a short .Rmd file that explains what you did, and includes links to any relevant files, such as slides, etc. which you can post on your GitHub repo (or another online site.) 1.2 Preparing your .Rmd file You should only submit ONE Rmd file. After completing these modifications, your .Rmd should look like this sample bookdown .Rmd. Create a concise, descriptive name for your project. For instance, name it base_r_ggplot_graph or something similar if your work is about contrasting/working with base R graphics and ggplot2 graphics. Check the .Rmd filenames in the project repo to make sure your name isn’t already taken. Your project name should be words only and joined with underscores, i.e. Do not include whitespace in the name. Create a copy of your .Rmd file with the new name. Completely delete the YAML header (the section at the top of the .Rmd that includes name, title, date, output, etc.) including the --- line. The first line should be a single hashtag (#) followed by your project name (this does not have to be exact same as the project folder name and may include white space), and it should be followed with one whitespace, otherwise bookdown will not render it as a header. Do not use single # headers anywhere else in the document. The second line should be blank, followed by your name(s): # Base R graphics vs. ggplot2 graphics Aaron Burr and Alexander Hamilton Your content starts here. If your project requires data, please use a built-in dataset or read directly from a URL, such as: df &lt;- readr::read_csv(&quot;https://people.sc.fsu.edu/~jburkardt/data/csv/addresses.csv&quot;) If you absolutely must include a data file, please use a small one, as for many reasons it is desirable to keep the repository size as small as possible. Want to get fancy? See the optional tweaks section below. 1.3 Submission Steps To submit your work, we will be following the instructions in this tutorial, which are provided in abbreviated form below, with specific instructions on naming conventions, content information, and other important details. Fork cc19 repo (this repo) to your GitHub account. Clone/download the forked repo to your local computer. Create a new branch and name it with your project name, in our case sample_project. If you forget to do so, check this tutorial to fix. Copy your modified .Rmd file with the same name into the root directory on the branch. In our example, it is sample_project.Rmd. Do not include an .html file. (In order for the bookdown package to work, all .Rmd files will be rendered behind the scenes.) [OPTIONAL] If you have other resources (such as images) included in your project, create a folder under resources/. In our example, it is resources/sample_project/. Put the resources files there. When you are ready to submit your project, push your branch to your remote repo. Follow this tutorial to create a pull request. If you follow the steps, we will merge it to the master branch. 1.4 Optional tweaks If you prefer for links from your chapter to open in new tabs, add {target=&quot;_blank&quot;} after the link, such as: [edav.info](edav.info){target=&quot;_blank&quot;} Note that your headers (##, ###, etc.) will be converted to numbered headings as such: ## –&gt; 3.1 ### –&gt; 3.1.1 These headings will appear as chapter subheadings and sub-subheadings in the navigation panel on the left. Think about a logical structure for users to navigate your chapter. We recommend using only ## and ### headings as subheadings such as 4.1.3.4 are generally not necessary and look messy. Unfortunately, there’s no simple way to preview your chapter before it’s actually merged into the project. (bookdown has preview_chapter() option but it only works after the entire book has been rendered at least once and that will become more and more complex and require more and more packages as the project grows.) If you really want to preview it, fork and clone this minimal bookdown repo, add your .Rmd file, click the “Build book” button on the Build tab (next to Git), and then open any of the .html files in the _book folder in a web browser to see the rendered book. (Do not click the Knit button as it will not build a bookdown book.) If you’re interested in more bookdown options, see the official reference book. Have more useful tweaks to share? Submit an issue or PR. 1.5 FAQ 1.5.1 What should I expect after creating a pull request? Within a week after you create a pull request, we will apply a label to it and assign an administrater who will review all the files you submit to see if they meet the requirements. It will take some time before we can process all the pull requests, so as long as you see your pull request has been labeled and assigned to an administrater, don’t worry. However, if the admin contacts you regarding the pull request, that usually means your files fail to meet some requirements. The admin will clearly state what is wrong, so please fix them as soon as possible. 1.5.2 What if I catch mistakes after my pull request is merged? You may submit additional pull requests to fix material on the site. If the edits are small, such as fixing typos, it is easiest to make the edits directly on GitHub, following these instructions. We will merge first pull requests before edits, so please be patient. 1.5.3 Other questions If you encounter other problems, please submit an issue and we will look into it. Thank you for your contributions! "],
["sample-project.html", "Chapter 2 Sample Project", " Chapter 2 Sample Project Nancy Pelosi and Donald Trump This chapter gives a sample layout of your Rmd file. Test Photo "],
["intro-to-ridgeline-plot.html", "Chapter 3 Intro to Ridgeline Plot 3.1 Overview 3.2 tl;dr 3.3 Simple examples 3.4 Theory 3.5 External resources", " Chapter 3 Intro to Ridgeline Plot Hojin Lee and Hyuk Joon Kwon 3.1 Overview Ridgeline plot is a set of overlapped density plots, and it helps us to compare multiple distirbutions among dataset. Professor Claus O. Wilke from UT Austin, who created ggridges package, commented about ridgeline plot as below: “Ridgeline plots are partially overlapping line plots that create the impression of a mountain range. They can be quite useful for visualizing changes in distributions over time or space. These types of plots have also been called “joyplots”, in reference to the iconic cover art for Joy Division’s album Unknown Pleasures. However, given the unfortunate origin of the name Joy Division, the term “joyplot” is now discouraged.&quot; In this section, we will discuss how to create ridgeline plots using the ggplot and ggridges libraries. 3.2 tl;dr For those who do not want to go through the documents, the below is the polished version of a ridgeline plot and the codes. library(ucidata) library(ggplot2) library(ggridges) library(viridis) library(plyr) library(nycflights13) weather$month &lt;- as.factor(weather$month) ggplot(weather, aes(x = temp, y = reorder(month, desc(month)), fill = factor(..quantile..))) + stat_density_ridges(quantiles = c(0.25,0.5,0.75) , quantile_lines = TRUE , geom = &quot;density_ridges_gradient&quot; , alpha = 0.6 , scale = 2.3) + scale_fill_viridis(discrete = TRUE , name = &quot;Quantile&quot; , alpha = 0.3 , option = &quot;cividis&quot;) + ggtitle(&quot;What is the weather like in NYC?&quot;, subtitle = &quot;Ridgeline plot for NYC temperature by months&quot;) + xlab(&quot;Temperature (F)&quot;) + ylab(&quot;Months&quot;) + labs(caption = &quot;Source: nycflights13::weather&quot;) + theme(plot.title = element_text(face=&quot;bold&quot;)) + theme(plot.subtitle = element_text(face=&quot;bold&quot;, color=&quot;grey&quot;)) + theme(plot.caption=element_text(color=&quot;grey&quot;)) For more information about dataset, type ?nycflights13::weather into the console. 3.3 Simple examples For one who needs friendly step by step approach, please read the below. First, we need to install ggridges and ggplot2 packages. #install.packages(&quot;ggridges&quot;) #install.packages(&quot;ggplot2&quot;) Make sure that the y variable is a categorical variable, otherwise the function will throw an error. You can use y = as.factor(data) to transfrom your y variable into a categorical variable. data &lt;- forest_fires data$day &lt;- factor(data$day , levels= rev(c(&quot;sun&quot;, &quot;mon&quot;, &quot;tue&quot;, &quot;wed&quot;, &quot;thu&quot;, &quot;fri&quot;, &quot;sat&quot;))) ggplot(data, aes(x = DMC, y = day)) + geom_density_ridges() If you do not want the ridgeline plot to touch each other, please use the scale variable. A scale of 1.0 will make the adjust graph to barely touch each other. If the scale is greater than 1 the graphs will overlap with each other. Otherwise, if the scale is less than 1 the graphs will not touch each other. data &lt;- forest_fires data$day &lt;- factor(data$day , levels= rev(c(&quot;sun&quot;, &quot;mon&quot;, &quot;tue&quot;, &quot;wed&quot;, &quot;thu&quot;, &quot;fri&quot;, &quot;sat&quot;))) ggplot(data, aes(x = DMC, y = day)) + geom_density_ridges(scale = 1.1) There is a raindrop function within ridgeline plots, which combine the rideline plots with scatter plots; the function will plot scatter plot under the rideline plot. library(ISwR) data2 &lt;- red.cell.folate ggplot(data2, aes(x = folate, y = ventilation)) + stat_density_ridges(quantiles = c(0.25,0.5,0.75) , geom=&quot;density_ridges_gradient&quot; , jittered_points = TRUE , position = &quot;raincloud&quot; , alpha = 0.6 , scale = 0.6) Morevoer, it is possible to divide the data into quantiles and draw lines in between. This way, it would be easier for us to observe the median value and the interquartile range. data &lt;- forest_fires data$day &lt;- factor(data$day , levels= rev(c(&quot;sun&quot;, &quot;mon&quot;, &quot;tue&quot;, &quot;wed&quot;, &quot;thu&quot;, &quot;fri&quot;, &quot;sat&quot;))) ggplot(data, aes(x = temp, y = day, fill = factor(..quantile..))) + stat_density_ridges(quantiles = c(0.25,0.5,0.75) , quantile_lines =TRUE , geom=&quot;density_ridges_gradient&quot;) + scale_fill_viridis(discrete = TRUE , name = &quot;Quantile&quot; , option = &quot;plasma&quot;) In below, we have merged all the functions we have introduced, and here is the result! data2 &lt;- red.cell.folate ggplot(data2, aes(x = folate, y = ventilation, fill = factor(..quantile..))) + stat_density_ridges(quantiles = c(0.25,0.5,0.75) , quantile_lines = TRUE , geom=&quot;density_ridges_gradient&quot; , jittered_points = TRUE , position = &quot;raincloud&quot; , alpha = 0.6 , scale = 0.6) + scale_fill_viridis(discrete=TRUE , name = &quot;Quantile&quot; , alpha = 0.3 , option = &quot;cividis&quot;) Here is one last cool feature of ridgeline plots where we can overlap distributions within same data group. This enables us to compare distributions not only among different data groups but also within same data groups. library(vcd) data3 &lt;- Arthritis ggplot(data3) + geom_density_ridges(aes(x = Age, y = Treatment, group = interaction(Treatment,Improved),fill = Improved), alpha = 0.7) 3.4 Theory Ridgeline plots are an overlap of histograms over y-axis, and this allows us to visualize and compare overall shape of distribution among different groups. They work very well when the dataset has high number of groups to show. Also, since we are overlapping distributions, we can save space for graphs. In other words, if the number of groups to represent is too small, plotting ridgeline plots might not be an optimal choice for data visualization. On the other hand, the ridgeline plots work well when there are clear differences in distributions. Otherwise, because of overlaps, they would cause more confusion when deciphering the data. Couple points to think about before plotting the ridgeline plots: Ordering of groups will change overall shape of the plots. Figure out the optimal bin size &amp; bandwidth argument for the visualization. 3.5 External resources The below has more examples with the ridgeline plots: https://cran.r-project.org/web/packages/ggridges/vignettes/introduction.html https://cmdlinetips.com/2018/03/how-to-plot-ridgeline-plots-in-r/ "],
["maps.html", "Chapter 4 Spatial Data 4.1 Choropleth maps 4.2 Square bins 4.3 Longitude / Latitude data", " Chapter 4 Spatial Data 4.1 Choropleth maps Choropleth maps use color to indicate the value of a variable within a defined region, generally political boundaries. “Mapping in R just got a whole lot easier” by Sharon Machlis (2017-03-03) offers a tutorial on using the tmap, tmaptools, and tigris packages to create choropleth maps. Note that with this approach, you will need to merge geographic shape files with your data files, and then map. “Step-by-Step Choropleth Map in R: A case of mapping Nepal” walks through the process of creating a choropleth map using rgdal and ggplot2. (We have not followed either of these tutorials step-by-step… if you do, please provide feedback by submitting an issue). The choroplethr package makes it simple to draw choropleth maps of U.S. states, countries, and census tracts, as well as countries of the world without dealing directly with shape files. The companion package, choroplethrZip, provides data for zip code level choropleths; choroplethrAdmin1 draws choropleths for administrative regions of world countries. The following is a brief tutorial on using these packages. Note: You must install also install choroplethrMaps for choroplethr to work. In addition, choroplethr requires a number of other dependencies which should be installed automatically, but if they aren’t, you can manually install the missing packages that you are notified about when you call library(choroplethr): maptools, and rgdal, sp. We’ll use the state.x77 dataset for this example: library(tidyverse) library(choroplethr) # data frame must contain &quot;region&quot; and &quot;value&quot; columns df_illiteracy &lt;- state.x77 %&gt;% as.data.frame() %&gt;% rownames_to_column(&quot;state&quot;) %&gt;% transmute(region = tolower(`state`), value = Illiteracy) state_choropleth(df_illiteracy, title = &quot;State Illiteracy Rates, 1977&quot;, legend = &quot;Percent Illiterate&quot;) Note: the choroplethr “free course” that you may come across arrives one lesson at a time by email over an extended period so not the best option unless you have a few weeks to spare. 4.2 Square bins Packages such as statebins create choropleth style maps with equal size regions that roughly represent the location of the region, but not the size or shape. Important: Don’t install statebins from CRAN; use the dev version – it contains many improvements, which are detailed in “Statebins Reimagined”. # devtools::install_github(&quot;hrbrmstr/statebins&quot;) library(statebins) df_illit &lt;- state.x77 %&gt;% as.data.frame() %&gt;% rownames_to_column(&quot;state&quot;) %&gt;% select(state, Illiteracy) # Note: direction = 1 switches the order of the fill scale # so darker shades represent higher illiteracy rates # (The default is -1). statebins(df_illit, value_col=&quot;Illiteracy&quot;, name = &quot;%&quot;, direction = 1) + ggtitle(&quot;State Illiteracy Rates, 1977&quot;) + theme_statebins() 4.3 Longitude / Latitude data Note that the options above work with political boundaries, based on the names of the regions that you provide. Such maps require packages with geographical boundary information. Longitude / latitude data, on the other hand, can be plotted simply as a scatterplot with x = longitude and y = latitude, without any background maps (just don’t mix up x &amp; y!) The first part of “Data wrangling visualisation and spatial analysis: R Workshop” by C. Brown, D. Schoeman, A. Richardson, and B. Venables provides a detailed walkthrough of spatial exploratory data analysis with copepod data (a type of zooplankton) using this technique with ggplot2::geom_point(). If background maps are desired, there are many options. The tutorial mentioned above provides examples using the maps or sf packages. It is a highly recommended resource as it covers much of the data science pipeline from the context of the problem to obtaining data, cleaning and transforming it, exploring the data, and finally modeling and predicting. Another good choice for background maps is ggmap, which offers several different map source options. Google Maps API was the go-to, but they now require you to enable billing through Google Cloud Platorm. You get $300 in free credit, but if providing a credit card isn’t your thing, you may consider using Stamen Maps instead, with the get_stamenmap() function. Use the development version of the package; instructions and extensive examples are available on the package’s GitHub page “Getting started Stamen maps with ggmap” will help you get started with Stamen maps through an example using the Sacramento dataset in the caret package. 4.3.1 Stamen Maps and ggmaps Here is an example to get started with ggmap using get_stamenmap() to plot the longitude/latitude maps. The data for the following plots is available at https://simplemaps.com/data/us-cities. The get_stamenmap() function reqiures a bounding box, i.e the top, bottom, left and right latitude/longitude of the map you want to plot. For example, the latitude/longitude for US map are as follows: bbox &lt;- c(bottom = 25.75, top = 49 , right = -67, left = -125) You can find these values from https://www.openstreetmap.org. The other important parameters of this function are zoom and maptype. Higher the zoom level, the more detailed your plot will be. Beaware that ggmap connects to Stamen Map server to download the map, so if your bounding box is large and zoom level is high, it will have to download a lot of data and may take some time. There are differnt types of plots available via Stamen Map like terrain, watercolor, toner which can be set to maptype parameter according to your preference. You can find about avaiable options in help (?get_stamenmap). For the following examples the maptype is set to ‘toner-lite’. Let’s plot the US map. library(ggmap) usmap &lt;- get_stamenmap(bbox = bbox, zoom = 6, maptype = &#39;toner-lite&#39;) ggmap(usmap) Great! We have the US map, now let’s use the US population data to see the population density across nation. Notice that we haven’t included Alaska in the map and hence will be removing the data from Alaska. library(dplyr) df &lt;- read.csv(unz(&#39;resources/ggmap/data/uscities.zip&#39;, &#39;uscities.csv&#39;)) # Removing data of Alaska from dataset df &lt;- df %&gt;% filter(state_name != &#39;Alaska&#39;) # Population density across US using points ggmap(usmap) + geom_point(data = df, mapping = aes(x = lng, y = lat, color = population)) + ggtitle(&#39;Population density across US&#39;) This is not good! Most of the points are overlapping and thus it is not easy to interpret what’s going on here. Let’s try alpha blending. # Population density across US using points ggmap(usmap) + geom_point(data = df, mapping = aes(x = lng, y = lat, color = population), stroke= 0, alpha = 0.1) + ggtitle(&#39;Population density across US&#39;) That’s much better! We can now easily identify the areas where population density is more. You might have noticed there is no light blue dot visible on the plot. This is because it must be lying somewhere between those dense areas. One such location is New York, you can find this out by zooming the plot. We can also look at popluation density using geom_density as follows # Population density across US using Density_2d ggmap(usmap) + geom_density_2d(data = df, mapping = aes(x = lng, y = lat, color = population)) + ggtitle(&#39;Population density across US&#39;) 4.3.2 Mutilayerd plots with ggmaps We can add multiple layers to the plot as described in earlier chapters. Let’s look at the location of military stations located across US along with population density. # Location of Military units df1 &lt;- df %&gt;% filter(military == TRUE) ggmap(usmap) + geom_point(data = df, mapping = aes(x = lng, y = lat, color = population, text = city), show.legend = F, stroke= 0, alpha = 0.1) + geom_point(data = df1, mapping = aes(x = lng, y = lat , text = city), show.legend = F, color = &#39;red&#39;) + ggtitle(&#39;Military stations across US&#39;) Let’s zoom the map for state of California. # California Boundaries CAbox &lt;- c(bottom = 32.213, top = 42.163 , right = -113.95, left = -124.585) camap &lt;- get_stamenmap(bbox = CAbox, zoom = 6, maptype = &#39;toner-lite&#39;) df3 &lt;- df %&gt;% filter(state_name == &#39;California&#39;) ggmap(camap) + geom_point(data = df3, mapping = aes(x = lng, y = lat, color = population), stroke= 0, alpha = 0.1) + ggtitle(&#39;Population density for California&#39;) 4.3.3 Getting Deeper This was just a glimpse of what you can do with ggmaps using the get_stamenmap(). Note that Stamen Maps is not limited to US and can be used to plot any part of the world. If you liked this alternative to Google Maps API, I highly recommend you to check the Stamen Maps website http://maps.stamen.com for more details. "],
["workshop.html", "Chapter 5 Workshop 5.1 EDAV Community Contribution-Bookdown workshop summary", " Chapter 5 Workshop Some groups of students have contributed to the community by running the following workshops. 5.1 EDAV Community Contribution-Bookdown workshop summary Weixi Yao and Wangzhi Li This introductory workshop on bookdown is designed to give a complete guide to the bookdown package. The workshop is split into two parts. The first part covers the basic information, including what is bookdown, why use bookdown and what are the other options avaiable. The second part serves as a practice session, and each attendee will try to build their own books using the instruction we provide. If the attendees want to know more about bookdown, they can always go back to our slides for reference. We have uplodaed our complete slide to the repo (url: https://github.com/yweixi/EDAV-community-contribution.git; file name: EDAV Community Contribution.pdf). Also, all the materials we use during the workshop can be found in a seperate repo (url: https://github.com/SafeguardLi/SafeguardLi.github.io.git). "],
["cartodb-tutorial.html", "Chapter 6 CartoDB Tutorial", " Chapter 6 CartoDB Tutorial Luis Lu and Timothy Huang This tutorial gives a brief overview on getting started with CartoDB, a powerful cloud computing tool that provides geospatial analysis and mapping tools. In this tutorial, we will go over the steps of getting set up on CartoDB, uploading your first dataset, creating your first map visualization, and exploring a few of Carto’s provided geospatial data analysis tools. Link to tutorial video: https://www.youtube.com/watch?v=GxRRXWTMMe8&amp;feature=youtu.be CartoDB "]
]
